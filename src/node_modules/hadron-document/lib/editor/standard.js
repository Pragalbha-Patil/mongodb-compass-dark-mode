"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var TypeChecker = require('hadron-type-checker');

var Events = require('../element-events');

var _require = require('../utils'),
    fieldStringLen = _require.fieldStringLen;
/**
 * Regex to match an array or object string.
 */


var ARRAY_OR_OBJECT = /^(\[|\{)(.+)(\]|\})$/;
/**
 * CRUD editor for standard values.
 */

var StandardEditor = /*#__PURE__*/function () {
  /**
   * Create the editor with the element.
   *
   * @param {Element} element - The hadron document element.
   */
  function StandardEditor(element) {
    _classCallCheck(this, StandardEditor);

    this.element = element;
  }
  /**
   * Edit the element with the provided value.
   *
   * @param {Object} value - The new value.
   */


  _createClass(StandardEditor, [{
    key: "edit",
    value: function edit(value) {
      var currentType = this.element.currentType;

      try {
        var newValue = TypeChecker.cast(value, currentType);
        this.element.edit(newValue);
      } catch (e) {
        this.element.setInvalid(value, currentType, e.message);
      }
    }
    /**
     * Edit the element via a paste.
     *
     * @param {String} value - The balue.
     */

  }, {
    key: "paste",
    value: function paste(value) {
      if (value.match(ARRAY_OR_OBJECT)) {
        this.edit(JSON.parse(value));

        this.element._bubbleUp(Events.Converted, this.element);
      } else {
        this.edit(value);
      }
    }
    /**
     * Get the number of characters the value should display.
     *
     * @param {Boolean} editMode - If the element is being edited.
     *
     * @returns {Number} The number of characters.
     */

  }, {
    key: "size",
    value: function size() {
      return fieldStringLen(this.element.currentValue);
    }
    /**
     * Get the value being edited.
     *
     * @returns {Object} The value.
     */

  }, {
    key: "value",
    value: function value() {
      return this.element.currentValue;
    } // Standard editing requires no special start/complete behaviour.

  }, {
    key: "start",
    value: function start() {}
  }, {
    key: "complete",
    value: function complete() {}
  }]);

  return StandardEditor;
}();

module.exports = StandardEditor;