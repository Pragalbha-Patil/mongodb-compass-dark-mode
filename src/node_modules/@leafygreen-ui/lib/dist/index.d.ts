/// <reference types="react" />
import * as typeIs from './typeIs';
export { typeIs };
/** Helper type to extract an HTML element's valid props */
export declare type HTMLElementProps<Element extends keyof JSX.IntrinsicElements, RefType extends HTMLElement = never> = Omit<JSX.IntrinsicElements[Element], 'ref'> & {
    ref?: [RefType] extends [never] ? never : React.Ref<RefType>;
    key?: React.Key | null;
};
/**
 * Helper that constructs a type requiring at least one of the passed keys
 * to be present in the passed interface.
 *
 * Example
 * ```
 * interface ExampleInterface {
 *   alwaysRequired: boolean,
 *   sometimesRequired: boolean,
 *   requiredOtherTimes: boolean,
 * }
 *
 * type ExampleEither = Either<ExampleInterface, 'sometimesRequired' | 'requiredOtherTimes'>
 *
 * // The above is equivalent to:
 * interface SharedInExampleInterface {
 *   alwaysRequired: boolean,
 * }
 *
 * interface FirstIsRequired extends SharedInExampleInterface {
 *   sometimesRequired: boolean,
 *   requiredOtherTimes?: boolean,
 * }
 *
 * interface SecondIsRequired extends SharedInExampleInterface {
 *   sometimesRequired?: boolean,
 *   requiredOtherTimes: boolean,
 * }
 *
 * type EquivalentToExampleEither = FirstIsRequired | SecondIsRequired
 * ```
 */
export declare type Either<T, Keys extends keyof T = keyof T> = Omit<T, Keys> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
/**
 * Helper that constructs mutually exclusive record types. Refer to tests for usage.
 */
export declare type OneOf<T1, T2> = (T1 & Partial<Record<Exclude<keyof T2, keyof T1>, never>>) | (T2 & Partial<Record<Exclude<keyof T1, keyof T2>, never>>);
/** Helper type to check if element is a specific React Component  */
export declare function isComponentType<T = React.ReactElement>(element: React.ReactNode, displayName: string): element is T;
/**
 * Utility for making it easier to couple a React Component to a css selector.
 * Useful when writing css selectors that rely on interactivity, i.e. :hover.
 * Example:
 *  const checkBoxWrapper = createDataProp('checkbox-wrapper');
 *  // Used as selector:
 *  css`&:hover ${checkboxWrapper.selector} { }`
 *  // Used on React Component
 *  <div {...checkboxWrapper.prop} />
 * @param {string} name Name of element we want to reference.
 */
export declare function createDataProp(name: string): {
    prop: {
        [x: string]: string;
    };
    selector: string;
};
/** Object mapping keyCodes to keys */
export declare const keyMap: {
    readonly ArrowUp: 38;
    readonly ArrowDown: 40;
    readonly ArrowLeft: 37;
    readonly ArrowRight: 39;
    readonly BracketLeft: 91;
    readonly Enter: 13;
    readonly Escape: 27;
    readonly Space: 32;
    readonly Tab: 9;
};
/**
 * An enum of accepted values for the "aria-current" attribute, used for
 * indicating current/active state across several contexts.
 *
 * The values "false", the empty string, and an ommission of this attribute
 * are all treated identically by user agents and screen readers.
 *
 * W3C Recommendation: https://www.w3.org/TR/wai-aria-1.1/#aria-current
 */
export declare const AriaCurrentValue: {
    readonly Page: "page";
    readonly Step: "step";
    readonly Location: "location";
    readonly Date: "date";
    readonly Time: "time";
    readonly True: "true";
    readonly Unset: "false";
};
export declare type AriaCurrentValue = typeof AriaCurrentValue[keyof typeof AriaCurrentValue];
/**
 * Accepts a type as an argument and makes all of the keys of the type optional
 */
export declare type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<RecursivePartial<U>> : T[P] extends object ? RecursivePartial<T[P]> : T[P] extends infer U | undefined ? RecursivePartial<U> | undefined : T[P] extends infer U | null ? RecursivePartial<U> | null : T[P];
};
/**
 * Helper function to use the typechecker to catch when
 * not all cases of a type have been handled.
 *
 * Example 1:
 *   let color: 'red' | 'blue' | 'green';
 *   switch (color) {
 *      case 'red':
 *        ...
 *        break;
 *      case 'blue':
 *        ...
 *        break;
 *      default:
 *        enforceExhaustive(color);
 *                          ^^^^^
 *          Argument of type 'string' is not assignable to parameter of type 'never'.
 *   }
 *
 * Example 2:
 *   let key: number | string | symbol;
 *
 *   if (typeof key === 'string') {
 *     ...
 *     return;
 *   }
 *
 *   if (typeof key === 'number') {
 *      ...
 *      return;
 *   }
 *
 *   enforceExhaustive(key);
 *                     ^^^
 *     Argument of type 'symbol' is not assignable to parameter of type 'never'.
 */
export declare function enforceExhaustive(value: never): never;
export declare const consoleOnce: {
    error: {
        (...data: any[]): void;
        (message?: any, ...optionalParams: any[]): void;
    };
    warn: {
        (...data: any[]): void;
        (message?: any, ...optionalParams: any[]): void;
    };
    log: {
        (...data: any[]): void;
        (message?: any, ...optionalParams: any[]): void;
    };
};
//# sourceMappingURL=index.d.ts.map