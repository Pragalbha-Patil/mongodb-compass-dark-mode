{"version":3,"file":"index.js","sources":["../src/typeIs.ts","../src/index.ts"],"sourcesContent":["export function element(node?: Node | null): node is HTMLElement {\n  return node != null && node.nodeType === Node.ELEMENT_NODE;\n}\n\nexport function button(el?: Node | null): el is HTMLButtonElement {\n  return element(el) && el.tagName.toLowerCase() === 'button';\n}\n\nexport function input(el?: Node | null): el is HTMLInputElement {\n  return element(el) && el.tagName.toLowerCase() === 'input';\n}\n\nexport function array(item?: any): item is Array<unknown> {\n  return item != null && item instanceof Array;\n}\n","import { once } from 'lodash';\nimport * as typeIs from './typeIs';\n\nexport { typeIs };\n\n/** Helper type to extract an HTML element's valid props */\nexport type HTMLElementProps<\n  Element extends keyof JSX.IntrinsicElements,\n  RefType extends HTMLElement = never\n> = Omit<JSX.IntrinsicElements[Element], 'ref'> & {\n  ref?: [RefType] extends [never] ? never : React.Ref<RefType>;\n  key?: React.Key | null;\n};\n\n/**\n * Helper that constructs a type requiring at least one of the passed keys\n * to be present in the passed interface.\n *\n * Example\n * ```\n * interface ExampleInterface {\n *   alwaysRequired: boolean,\n *   sometimesRequired: boolean,\n *   requiredOtherTimes: boolean,\n * }\n *\n * type ExampleEither = Either<ExampleInterface, 'sometimesRequired' | 'requiredOtherTimes'>\n *\n * // The above is equivalent to:\n * interface SharedInExampleInterface {\n *   alwaysRequired: boolean,\n * }\n *\n * interface FirstIsRequired extends SharedInExampleInterface {\n *   sometimesRequired: boolean,\n *   requiredOtherTimes?: boolean,\n * }\n *\n * interface SecondIsRequired extends SharedInExampleInterface {\n *   sometimesRequired?: boolean,\n *   requiredOtherTimes: boolean,\n * }\n *\n * type EquivalentToExampleEither = FirstIsRequired | SecondIsRequired\n * ```\n */\nexport type Either<T, Keys extends keyof T = keyof T> = Omit<T, Keys> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\n/**\n * Helper that constructs mutually exclusive record types. Refer to tests for usage.\n */\nexport type OneOf<T1, T2> =\n  | (T1 & Partial<Record<Exclude<keyof T2, keyof T1>, never>>)\n  | (T2 & Partial<Record<Exclude<keyof T1, keyof T2>, never>>);\n\n/** Helper type to check if element is a specific React Component  */\nexport function isComponentType<T = React.ReactElement>(\n  element: React.ReactNode,\n  displayName: string,\n): element is T {\n  return (\n    element != null &&\n    typeof element === 'object' &&\n    'type' in element &&\n    (element.type as any).displayName === displayName\n  );\n}\n\n/**\n * Utility for making it easier to couple a React Component to a css selector.\n * Useful when writing css selectors that rely on interactivity, i.e. :hover.\n * Example:\n *  const checkBoxWrapper = createDataProp('checkbox-wrapper');\n *  // Used as selector:\n *  css`&:hover ${checkboxWrapper.selector} { }`\n *  // Used on React Component\n *  <div {...checkboxWrapper.prop} />\n * @param {string} name Name of element we want to reference.\n */\nexport function createDataProp(name: string) {\n  // ts:emit throws an error if this is not typed. Usually this can be inferred.\n  const prefix = 'data-leafygreen-ui' as string;\n\n  return {\n    prop: {\n      [prefix]: name,\n    },\n    selector: `[${prefix}=\"${name}\"]`,\n  };\n}\n\n/** Object mapping keyCodes to keys */\nexport const keyMap = {\n  ArrowUp: 38,\n  ArrowDown: 40,\n  ArrowLeft: 37,\n  ArrowRight: 39,\n  BracketLeft: 91,\n  Enter: 13,\n  Escape: 27,\n  Space: 32,\n  Tab: 9,\n} as const;\n\n/**\n * An enum of accepted values for the \"aria-current\" attribute, used for\n * indicating current/active state across several contexts.\n *\n * The values \"false\", the empty string, and an ommission of this attribute\n * are all treated identically by user agents and screen readers.\n *\n * W3C Recommendation: https://www.w3.org/TR/wai-aria-1.1/#aria-current\n */\nexport const AriaCurrentValue = {\n  Page: 'page', // current value in a set of pagination links\n  Step: 'step', // current value in a step indicator\n  Location: 'location', // current value in a chart or other visual flow\n  Date: 'date', // current value in a calendar or date picker\n  Time: 'time', // current value in a timetable or time picker\n  True: 'true', // (fallback) current value in any set of options/elements\n  Unset: 'false', // equivalent to omitting the aria-current attribute\n} as const;\n\nexport type AriaCurrentValue = typeof AriaCurrentValue[keyof typeof AriaCurrentValue];\n\n/**\n * Accepts a type as an argument and makes all of the keys of the type optional\n */\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<RecursivePartial<U>>\n    : T[P] extends object\n    ? RecursivePartial<T[P]>\n    : T[P] extends infer U | undefined\n    ? RecursivePartial<U> | undefined\n    : T[P] extends infer U | null\n    ? RecursivePartial<U> | null\n    : T[P];\n};\n\n/**\n * Helper function to use the typechecker to catch when\n * not all cases of a type have been handled.\n *\n * Example 1:\n *   let color: 'red' | 'blue' | 'green';\n *   switch (color) {\n *      case 'red':\n *        ...\n *        break;\n *      case 'blue':\n *        ...\n *        break;\n *      default:\n *        enforceExhaustive(color);\n *                          ^^^^^\n *          Argument of type 'string' is not assignable to parameter of type 'never'.\n *   }\n *\n * Example 2:\n *   let key: number | string | symbol;\n *\n *   if (typeof key === 'string') {\n *     ...\n *     return;\n *   }\n *\n *   if (typeof key === 'number') {\n *      ...\n *      return;\n *   }\n *\n *   enforceExhaustive(key);\n *                     ^^^\n *     Argument of type 'symbol' is not assignable to parameter of type 'never'.\n */\nexport function enforceExhaustive(value: never): never {\n  throw Error(`Received unhandled value: ${value}`);\n}\n\nexport const consoleOnce = {\n  error: once(console.error),\n  warn: once(console.warn),\n  log: once(console.log),\n};\n"],"names":["element","node","nodeType","Node","ELEMENT_NODE","el","tagName","toLowerCase","item","Array","consoleOnce","error","once","console","warn","log","Page","Step","Location","Date","Time","True","Unset","name","prefix","prop","selector","concat","value","Error","displayName","_typeof","type","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","BracketLeft","Enter","Escape","Space","Tab"],"mappings":"mgBAAO,SAASA,EAAQC,GACtB,OAAe,MAARA,GAAgBA,EAAKC,WAAaC,KAAKC,kEAEzC,SAAgBC,GACrB,OAAOL,EAAQK,IAAoC,WAA7BA,EAAGC,QAAQC,qBAE5B,SAAeF,GACpB,OAAOL,EAAQK,IAAoC,UAA7BA,EAAGC,QAAQC,qBAE5B,SAAeC,GACpB,OAAe,MAARA,GAAgBA,aAAgBC,aCoG9BC,EAAc,CACvBC,MAAOC,OAAKC,QAAQF,OACpBG,KAAMF,OAAKC,QAAQC,MACnBC,IAAKH,OAAKC,QAAQE,yBA3DU,CAC5BC,KAAM,OAENC,KAAM,OAENC,SAAU,WAEVC,KAAM,OAENC,KAAM,OAENC,KAAM,OAENC,MAAO,0CA5CF,SAAwBC,GAE7B,UAAIC,EAAS,qBACb,MAAO,CACLC,QAAsB,KAAID,IAAQD,kGAClCG,SAAU,IAAIC,OAAOH,EAAQ,MAAOG,OAAOJ,EAAM,4BA+E9C,SAA2BK,GAChC,MAAMC,MAAM,6BAA6BF,OAAOC,uBApG3C,SAAyB5B,EAAS8B,GACvC,OAAkB,MAAX9B,GAAwC,WAArB+B,EAAQ/B,IAAyB,SAAUA,GAAWA,EAAQgC,KAAKF,cAAgBA,YAwB3F,CAClBG,QAAS,GACTC,UAAW,GACXC,UAAW,GACXC,WAAY,GACZC,YAAa,GACbC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,IAAK"}