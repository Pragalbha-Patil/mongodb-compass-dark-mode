import React, { useRef } from 'react';
import { InternalProps as InternalOptionProps, OptionElement } from './Option';
import { OptionGroupElement } from './OptionGroup';
export declare function traverseSelectChildren(children: React.ReactNode, optionFn: (child: OptionElement, group?: OptionGroupElement) => void): void;
export declare function convertToInternalElements(children: React.ReactNode, optionFn: (child: OptionElement, group?: OptionGroupElement) => InternalOptionProps, fallbackFn?: (child: React.ReactNode) => void): React.ReactNode;
export declare function getOptionValue(option: OptionElement | null): string;
export declare function isOptionDisabled(option: OptionElement, group: OptionGroupElement | undefined): boolean;
export declare function isOptionSelectable(option: OptionElement, group: OptionGroupElement | undefined, value: string): boolean;
/**
 * Given the selected option from a previous render, attempts to find a
 * match among the options of the next render to become the next selected
 * option, so that the state of the component doesn't need to be lost.
 */
export declare function reconcileOption(children: React.ReactNode, previousOption: OptionElement): OptionElement | null;
export declare function useObservedRef<T>(callback: (value: T) => void, initialValue: T, options: {
    initialValue: T;
    deps?: React.DependencyList;
}): React.MutableRefObject<T>;
export declare function useObservedRef<T>(callback: (value: T) => void, options?: {
    initialValue: T | null;
    deps?: React.DependencyList;
}): React.RefObject<T>;
export declare function useObservedRef<T>(callback: (value: T | undefined) => void, options?: {
    deps?: React.DependencyList;
}): React.MutableRefObject<T>;
declare type SettableRef<T> = React.RefCallback<T> | React.MutableRefObject<T>;
declare type ValueOrArray<T> = T | ReadonlyArray<T>;
export declare function useForwardedRef<T>(forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>, initialValue: T): React.MutableRefObject<T>;
export declare function useForwardedRef<T>(forwardedRefOrRefs: ValueOrArray<SettableRef<T | null> | null>, initialValue: T | null): React.RefObject<T>;
/**
 * TODO: Explore obsoleting `useElementNode` in favor of this
 */
export declare const useStateRef: typeof useRef;
export {};
//# sourceMappingURL=utils.d.ts.map