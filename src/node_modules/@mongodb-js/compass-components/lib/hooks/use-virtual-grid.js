"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useVirtualGridArrowNavigation = void 0;
const react_1 = require("react");
function closest(node, cond) {
    var _a;
    if (typeof cond === 'string') {
        return (_a = node === null || node === void 0 ? void 0 : node.closest(cond)) !== null && _a !== void 0 ? _a : null;
    }
    let parent = node;
    while (parent) {
        if (cond(parent)) {
            return parent;
        }
        parent = parent.parentElement;
    }
    return null;
}
function vgridItemSelector(idx) {
    return idx ? `[data-vlist-item-idx="${idx}"]` : '[data-vlist-item-idx]';
}
function getItemIndex(node) {
    if (!node.dataset.vlistItemIdx) {
        throw new Error('Trying to get vgrid item index from an non-item element');
    }
    return Number(node.dataset.vlistItemIdx);
}
function useVirtualGridArrowNavigation({ colCount, rowCount, itemsCount, resetActiveItemOnBlur = true, pageSize = 3, defaultCurrentTabbable = 0, onFocusMove, }) {
    const rootNode = (0, react_1.useRef)(null);
    const [tabIndex, setTabIndex] = (0, react_1.useState)(0);
    const [currentTabbable, setCurrentTabbable] = (0, react_1.useState)(defaultCurrentTabbable);
    const onFocus = (0, react_1.useCallback)((evt) => {
        if (evt.target === evt.currentTarget) {
            setTabIndex(-1);
        }
        else {
            const focusedItem = closest(evt.target, vgridItemSelector());
            if (focusedItem) {
                setTabIndex(-1);
                setCurrentTabbable(getItemIndex(focusedItem));
            }
        }
    }, [defaultCurrentTabbable]);
    const onBlur = (0, react_1.useCallback)(() => {
        const isFocusInside = closest(document.activeElement, (node) => node === rootNode.current) !== null;
        if (!isFocusInside) {
            setTabIndex(0);
            if (resetActiveItemOnBlur) {
                setCurrentTabbable(defaultCurrentTabbable);
            }
        }
    }, [resetActiveItemOnBlur, defaultCurrentTabbable]);
    const onMouseDown = (0, react_1.useCallback)((evt) => {
        var _a;
        const gridItem = closest(evt.target, vgridItemSelector());
        if (!gridItem) {
            evt.preventDefault();
            (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.blur();
        }
    }, []);
    const focusProps = { tabIndex, onFocus, onBlur, onMouseDown };
    const onKeyDown = (0, react_1.useCallback)((evt) => {
        const target = evt.target;
        if (rootNode.current &&
            rootNode.current.contains(target) &&
            target.dataset.vlistItemIdx) {
            let nextTabbableIndex = -1;
            if (evt.key === 'ArrowUp') {
                evt.preventDefault();
                evt.stopPropagation();
                nextTabbableIndex =
                    rowCount === 1 ? currentTabbable - 1 : currentTabbable - colCount;
            }
            if (evt.key === 'ArrowDown') {
                evt.preventDefault();
                evt.stopPropagation();
                nextTabbableIndex =
                    rowCount === 1 ? currentTabbable + 1 : currentTabbable + colCount;
            }
            if (evt.key === 'ArrowLeft') {
                evt.stopPropagation();
                nextTabbableIndex = currentTabbable - 1;
            }
            if (evt.key === 'ArrowRight') {
                evt.stopPropagation();
                nextTabbableIndex = currentTabbable + 1;
            }
            if (evt.key === 'Home') {
                evt.preventDefault();
                evt.stopPropagation();
                if (evt.ctrlKey) {
                    nextTabbableIndex = 0;
                }
                else {
                    nextTabbableIndex =
                        colCount * Math.floor(currentTabbable / colCount);
                }
            }
            if (evt.key === 'End') {
                evt.preventDefault();
                evt.stopPropagation();
                if (evt.ctrlKey) {
                    nextTabbableIndex = itemsCount - 1;
                }
                else {
                    nextTabbableIndex =
                        colCount * Math.floor(currentTabbable / colCount) +
                            (colCount - 1);
                }
            }
            if (evt.key === 'PageUp') {
                evt.preventDefault();
                evt.stopPropagation();
                const currRow = Math.floor(currentTabbable / colCount);
                const pageStep = Math.min(currRow, pageSize);
                nextTabbableIndex = currentTabbable - colCount * pageStep;
            }
            if (evt.key === 'PageDown') {
                evt.preventDefault();
                evt.stopPropagation();
                const currRow = Math.floor(currentTabbable / colCount);
                const pageStep = Math.min(rowCount - 1 - currRow, pageSize);
                nextTabbableIndex = currentTabbable + colCount * pageStep;
            }
            if (nextTabbableIndex !== currentTabbable &&
                nextTabbableIndex >= 0 &&
                nextTabbableIndex < itemsCount) {
                setCurrentTabbable(nextTabbableIndex);
            }
        }
    }, [currentTabbable, itemsCount, rowCount, colCount, pageSize]);
    const activeCurrentTabbable = tabIndex === 0 ? -1 : currentTabbable;
    (0, react_1.useEffect)(() => {
        if (activeCurrentTabbable >= 0) {
            const gridItem = closest(document.activeElement, vgridItemSelector());
            const shouldMoveFocus = !gridItem || getItemIndex(gridItem) !== activeCurrentTabbable;
            if (shouldMoveFocus) {
                onFocusMove(activeCurrentTabbable);
                const frameId = requestAnimationFrame(() => {
                    var _a, _b;
                    (_b = (_a = rootNode.current) === null || _a === void 0 ? void 0 : _a.querySelector(vgridItemSelector(currentTabbable))) === null || _b === void 0 ? void 0 : _b.focus();
                });
                return () => {
                    cancelAnimationFrame(frameId);
                };
            }
        }
    }, [activeCurrentTabbable]);
    return [{ ref: rootNode, onKeyDown, ...focusProps }, activeCurrentTabbable];
}
exports.useVirtualGridArrowNavigation = useVirtualGridArrowNavigation;
//# sourceMappingURL=use-virtual-grid.js.map