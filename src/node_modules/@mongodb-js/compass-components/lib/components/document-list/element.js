"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HadronElement = void 0;
const react_1 = __importStar(require("react"));
const emotion_1 = require("@leafygreen-ui/emotion");
const palette_1 = require("@leafygreen-ui/palette");
const hadron_document_1 = require("hadron-document");
const bson_value_1 = __importDefault(require("../bson-value"));
const tokens_1 = require("@leafygreen-ui/tokens");
const element_editors_1 = require("./element-editors");
const element_actions_1 = require("./element-actions");
const font_awesome_icon_1 = require("./font-awesome-icon");
const auto_focus_context_1 = require("./auto-focus-context");
const use_force_update_1 = require("./use-force-update");
function getEditorByType(type) {
    switch (type) {
        case 'Date':
        case 'String':
        case 'Decimal128':
        case 'Double':
        case 'Int32':
        case 'Int64':
        case 'Null':
        case 'Undefined':
        case 'ObjectId':
            return hadron_document_1.ElementEditor[`${type}Editor`];
        default:
            return hadron_document_1.ElementEditor.StandardEditor;
    }
}
function useElementEditor(el) {
    const editor = (0, react_1.useRef)(null);
    if (!editor.current) {
        const Editor = getEditorByType(el.currentType);
        editor.current = new Editor(el);
    }
    (0, react_1.useEffect)(() => {
        var _a, _b;
        if (((_a = editor.current) === null || _a === void 0 ? void 0 : _a.element.uuid) !== el.uuid ||
            ((_b = editor.current) === null || _b === void 0 ? void 0 : _b.element.currentType) !== el.currentType) {
            const Editor = getEditorByType(el.currentType);
            editor.current = new Editor(el);
        }
    }, [el, el.uuid, el.currentType]);
    return editor.current;
}
function useHadronElement(el) {
    var _a, _b, _c;
    const forceUpdate = (0, use_force_update_1.useForceUpdate)();
    const editor = useElementEditor(el);
    const [isDuplicateKey, setIsDuplicateKey] = (0, react_1.useState)(() => {
        return el.isDuplicateKey(el.currentKey);
    });
    const onElementChanged = (0, react_1.useCallback)((changedElement) => {
        if (el.uuid === changedElement.uuid) {
            forceUpdate();
        }
    }, [el, forceUpdate]);
    const onElementAddedOrRemoved = (0, react_1.useCallback)((_el, parentEl) => {
        if (el === parentEl) {
            forceUpdate();
        }
    }, [el, forceUpdate]);
    (0, react_1.useEffect)(() => {
        el.on(hadron_document_1.ElementEvents.Converted, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Edited, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Reverted, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Invalid, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Valid, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Added, onElementAddedOrRemoved);
        el.on(hadron_document_1.ElementEvents.Removed, onElementAddedOrRemoved);
        return () => {
            el.off(hadron_document_1.ElementEvents.Converted, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Edited, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Reverted, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Valid, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Added, onElementAddedOrRemoved);
            el.off(hadron_document_1.ElementEvents.Removed, onElementAddedOrRemoved);
        };
    }, [el, onElementChanged, onElementAddedOrRemoved]);
    const isValid = el.isCurrentTypeValid();
    return {
        id: el.uuid,
        key: {
            value: el.currentKey,
            change(newVal) {
                setIsDuplicateKey(el.isDuplicateKey(newVal));
                el.rename(newVal);
            },
            editable: el.isKeyEditable() && ((_a = el.parent) === null || _a === void 0 ? void 0 : _a.currentType) !== 'Array',
            valid: !isDuplicateKey,
            validationMessage: isDuplicateKey
                ? `Duplicate key "${el.currentKey}" - this will overwrite previous values`
                : null,
        },
        value: {
            value: editor.value(),
            originalValue: el.currentValue,
            change(newVal) {
                editor.edit(newVal);
            },
            editable: el.isValueEditable() &&
                el.currentType !== 'Object' &&
                el.currentType !== 'Array',
            valid: isValid,
            validationMessage: !isValid ? (_b = el.invalidTypeMessage) !== null && _b !== void 0 ? _b : null : null,
        },
        type: {
            value: el.currentType,
            change(newVal) {
                el.changeType(newVal);
            },
        },
        revert: el.isRevertable() ? el.revert.bind(el) : null,
        remove: el.isNotActionable() ? null : el.remove.bind(el),
        expandable: Boolean(el.elements),
        children: el.elements ? [...el.elements] : [],
        level: el.level,
        parentType: (_c = el.parent) === null || _c === void 0 ? void 0 : _c.currentType,
        removed: el.isRemoved(),
    };
}
const buttonReset = (0, emotion_1.css)({
    margin: 0,
    padding: 0,
    border: 'none',
    background: 'none',
});
const hadronElement = (0, emotion_1.css)({
    display: 'flex',
    paddingLeft: tokens_1.spacing[2],
    paddingRight: tokens_1.spacing[2],
    '&:hover': {
        backgroundColor: palette_1.uiColors.gray.light2,
    },
});
const elementInvalid = (0, emotion_1.css)({
    backgroundColor: palette_1.uiColors.yellow.light3,
    '&:hover': {
        backgroundColor: palette_1.uiColors.yellow.light2,
    },
});
const elementRemoved = (0, emotion_1.css)({
    backgroundColor: palette_1.uiColors.red.light3,
    '&:hover': {
        backgroundColor: palette_1.uiColors.red.light2,
    },
});
const elementActions = (0, emotion_1.css)({
    flex: 'none',
    width: tokens_1.spacing[3],
});
const elementLineNumber = (0, emotion_1.css)({
    flex: 'none',
    position: 'relative',
    marginLeft: tokens_1.spacing[1],
    boxSizing: 'content-box',
});
const addFieldActionsContainer = (0, emotion_1.css)({
    position: 'absolute',
    top: 0,
    right: 0,
});
const lineNumberCount = (0, emotion_1.css)({
    '&::before': {
        display: 'block',
        width: '100%',
        counterIncrement: 'line-number',
        content: 'counter(line-number)',
        textAlign: 'end',
        color: palette_1.uiColors.gray.base,
    },
});
const lineNumberInvalid = (0, emotion_1.css)({
    backgroundColor: palette_1.uiColors.yellow.base,
    '&::before': {
        color: palette_1.uiColors.yellow.dark2,
    },
});
const lineNumberRemoved = (0, emotion_1.css)({
    backgroundColor: palette_1.uiColors.red.base,
    color: palette_1.uiColors.red.light3,
    '&::before': {
        color: palette_1.uiColors.red.light3,
    },
});
const elementSpacer = (0, emotion_1.css)({
    flex: 'none',
});
const elementExpand = (0, emotion_1.css)({
    width: tokens_1.spacing[3],
    flex: 'none',
});
const elementKey = (0, emotion_1.css)({
    flex: 'none',
    fontWeight: 'bold',
    maxWidth: '60%',
});
const elementDivider = (0, emotion_1.css)({
    flex: 'none',
    userSelect: 'none',
});
const elementValue = (0, emotion_1.css)({
    flex: 1,
    minWidth: 0,
    maxWidth: '100%',
});
const elementType = (0, emotion_1.css)({
    flex: 'none',
    marginLeft: tokens_1.spacing[1],
});
const actions = (0, emotion_1.css)({
    display: 'none',
});
const actionsVisible = (0, emotion_1.css)({
    '[data-document-element="true"]:hover &, [data-document-element="true"]:focus-within &': {
        display: 'block',
    },
});
const lineNumberCountHidden = (0, emotion_1.css)({
    '[data-document-element="true"]:hover &::before, [data-document-element="true"]:focus-within &::before': {
        visibility: 'hidden',
    },
});
const HadronElement = ({ value: element, editable, editingEnabled, onEditStart, allExpanded, lineNumberSize, onAddElement, }) => {
    const autoFocus = (0, auto_focus_context_1.useAutoFocusContext)();
    const [expanded, setExpanded] = (0, react_1.useState)(allExpanded);
    const { id, key, value, type, revert, remove, expandable, children, level, parentType, removed, } = useHadronElement(element);
    (0, react_1.useEffect)(() => {
        setExpanded(allExpanded);
    }, [allExpanded]);
    const toggleExpanded = (0, react_1.useCallback)(() => {
        setExpanded((val) => !val);
    }, []);
    const lineNumberMinWidth = (0, react_1.useMemo)(() => {
        if (editingEnabled) {
            const charCount = String(lineNumberSize).length;
            return charCount > 2 ? `${charCount}.5ch` : tokens_1.spacing[3];
        }
        return tokens_1.spacing[3];
    }, [lineNumberSize, editingEnabled]);
    const onLineClick = (0, react_1.useCallback)(() => {
        toggleExpanded();
    }, [toggleExpanded]);
    const isValid = key.valid && value.valid;
    const shouldShowActions = editingEnabled;
    const elementProps = {
        className: (0, emotion_1.cx)(hadronElement, removed ? elementRemoved : editingEnabled && !isValid && elementInvalid),
        onClick: onLineClick,
    };
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("div", { "data-document-element": "true", "data-testid": "hadron-document-element", "data-id": element.uuid, ...elementProps },
            editable && (react_1.default.createElement("div", { className: elementActions },
                react_1.default.createElement("div", { className: (0, emotion_1.cx)(actions, shouldShowActions && actionsVisible) },
                    react_1.default.createElement(element_actions_1.EditActions, { onRevert: revert, onRemove: remove, editing: editingEnabled })))),
            editable && (react_1.default.createElement("div", { className: (0, emotion_1.cx)(elementLineNumber, editingEnabled && lineNumberCount, shouldShowActions && lineNumberCountHidden, removed
                    ? lineNumberRemoved
                    : editingEnabled && !isValid && lineNumberInvalid), style: { minWidth: lineNumberMinWidth } },
                react_1.default.createElement("div", { className: (0, emotion_1.cx)(actions, addFieldActionsContainer, shouldShowActions && actionsVisible) },
                    react_1.default.createElement(element_actions_1.AddFieldActions, { editing: editingEnabled, type: type.value, parentType: parentType && parentType === 'Document'
                            ? 'Object'
                            : parentType, keyName: key.value, onAddFieldAfterElement: () => {
                            const el = element.insertSiblingPlaceholder();
                            onAddElement(el);
                        }, onAddFieldToElement: type.value === 'Object' || type.value === 'Array'
                            ? () => {
                                const el = element.insertPlaceholder();
                                onAddElement(el);
                                setExpanded(true);
                            }
                            : undefined })))),
            react_1.default.createElement("div", { className: elementSpacer, style: { width: (editable ? tokens_1.spacing[2] : 0) + tokens_1.spacing[3] * level } }),
            react_1.default.createElement("div", { className: elementExpand }, expandable && (react_1.default.createElement("button", { className: buttonReset, "aria-pressed": expanded, "aria-label": expanded ? 'Collapse field items' : 'Expand field items', onClick: (evt) => {
                    evt.stopPropagation();
                    toggleExpanded();
                } },
                react_1.default.createElement(font_awesome_icon_1.FontAwesomeIcon, { icon: expanded ? 'expanded' : 'collapsed' })))),
            react_1.default.createElement("div", { className: elementKey, "data-testid": "hadron-document-element-key" }, key.editable ? (react_1.default.createElement(element_editors_1.KeyEditor, { value: key.value, valid: key.valid, validationMessage: key.validationMessage, onChange: (newVal) => {
                    key.change(newVal);
                }, autoFocus: (autoFocus === null || autoFocus === void 0 ? void 0 : autoFocus.id) === id && autoFocus.type === 'key', editing: editingEnabled, onEditStart: () => {
                    onEditStart === null || onEditStart === void 0 ? void 0 : onEditStart(element.uuid, 'key');
                } })) : (react_1.default.createElement("span", null, key.value))),
            react_1.default.createElement("div", { className: elementDivider, role: "presentation" }, ":\u00A0"),
            react_1.default.createElement("div", { className: elementValue, "data-testid": "hadron-document-element-value" }, value.editable ? (react_1.default.createElement(element_editors_1.ValueEditor, { type: type.value, originalValue: value.originalValue, value: value.value, valid: value.valid, validationMessage: value.validationMessage, onChange: (newVal) => {
                    value.change(newVal);
                }, autoFocus: (autoFocus === null || autoFocus === void 0 ? void 0 : autoFocus.id) === id && autoFocus.type === 'value', editing: editingEnabled, onEditStart: () => {
                    onEditStart === null || onEditStart === void 0 ? void 0 : onEditStart(element.uuid, 'value');
                } })) : (react_1.default.createElement(bson_value_1.default, { type: type.value, value: value.originalValue }))),
            editable && (react_1.default.createElement("div", { className: elementType, "data-testid": "hadron-document-element-type" },
                react_1.default.createElement(element_editors_1.TypeEditor, { editing: editingEnabled, type: type.value, onChange: (newType) => {
                        type.change(newType);
                    } })))),
        expandable &&
            expanded &&
            children.map((el) => {
                return (react_1.default.createElement(exports.HadronElement, { key: el.uuid, value: el, editable: editable, editingEnabled: editingEnabled, onEditStart: onEditStart, allExpanded: allExpanded, lineNumberSize: lineNumberSize, onAddElement: onAddElement }));
            })));
};
exports.HadronElement = HadronElement;
//# sourceMappingURL=element.js.map